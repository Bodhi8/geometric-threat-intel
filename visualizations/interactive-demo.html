<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Threat Plane | 3D Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
      background: #0a0a1a;
      color: #e0e0e0;
      overflow: hidden;
      height: 100vh;
    }
    
    #container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .overlay {
      position: absolute;
      pointer-events: none;
      z-index: 10;
    }
    
    .header {
      top: 0;
      left: 0;
      right: 0;
      padding: 20px 30px;
      background: linear-gradient(180deg, rgba(10,10,26,0.95) 0%, transparent 100%);
    }
    
    .header h1 {
      font-size: 24px;
      font-weight: 400;
      letter-spacing: 3px;
      color: #fff;
    }
    
    .header h1 span { color: #ff6b6b; }
    
    .header p {
      font-size: 11px;
      letter-spacing: 2px;
      color: #6b6b8d;
      margin-top: 5px;
    }
    
    .stats {
      position: absolute;
      top: 20px;
      right: 30px;
      display: flex;
      gap: 20px;
      z-index: 10;
    }
    
    .stat {
      text-align: center;
    }
    
    .stat-value {
      font-size: 22px;
      font-weight: 600;
    }
    
    .stat-label {
      font-size: 9px;
      color: #6b6b8d;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .critical .stat-value { color: #ff6b6b; }
    .high .stat-value { color: #ffe66d; }
    .medium .stat-value { color: #4ecdc4; }
    .low .stat-value { color: #95e1d3; }
    
    .panel {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(10,10,26,0.9);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 16px;
      pointer-events: auto;
      min-width: 180px;
      z-index: 10;
    }
    
    .panel-left { left: 20px; }
    .panel-right { right: 20px; }
    
    .panel-title {
      font-size: 9px;
      letter-spacing: 2px;
      color: #6b6b8d;
      margin-bottom: 12px;
      text-transform: uppercase;
    }
    
    .cluster-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      margin-bottom: 2px;
    }
    
    .cluster-item:hover,
    .cluster-item.active {
      background: rgba(255,255,255,0.1);
    }
    
    .cluster-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    
    .footer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 15px 30px;
      background: linear-gradient(0deg, rgba(10,10,26,0.95) 0%, transparent 100%);
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      letter-spacing: 1px;
      z-index: 10;
    }
    
    .footer-left { color: #6b6b8d; }
    .footer-right { color: #4ecdc4; }
    
    .equation {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(10,10,26,0.8);
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 12px;
      font-style: italic;
      color: #8b8bab;
      border: 1px solid rgba(255,255,255,0.05);
      z-index: 10;
    }

    .controls label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      margin-bottom: 8px;
      cursor: pointer;
    }

    .controls input[type="checkbox"] {
      accent-color: #4ecdc4;
    }

    .controls input[type="range"] {
      width: 100%;
      accent-color: #ffe66d;
    }

    .control-label {
      font-size: 10px;
      color: #6b6b8d;
      margin-bottom: 4px;
    }

    hr {
      border: none;
      border-top: 1px solid rgba(255,255,255,0.1);
      margin: 12px 0;
    }

    .info {
      font-size: 9px;
      color: #6b6b8d;
    }

    .info span {
      color: #fff;
    }

    .info .highlight {
      color: #ff6b6b;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  
  <div class="overlay header">
    <h1><span>◆</span> THREAT PLANE</h1>
    <p>Geometric Risk Surface Visualization</p>
  </div>
  
  <div class="stats">
    <div class="stat critical">
      <div class="stat-value" id="critical-count">0</div>
      <div class="stat-label">Critical</div>
    </div>
    <div class="stat high">
      <div class="stat-value" id="high-count">0</div>
      <div class="stat-label">High</div>
    </div>
    <div class="stat medium">
      <div class="stat-value" id="medium-count">0</div>
      <div class="stat-label">Medium</div>
    </div>
    <div class="stat low">
      <div class="stat-value" id="low-count">0</div>
      <div class="stat-label">Low</div>
    </div>
  </div>
  
  <div class="panel panel-left">
    <div class="panel-title">Threat Clusters</div>
    <div id="cluster-list"></div>
  </div>
  
  <div class="panel panel-right">
    <div class="panel-title">Controls</div>
    <div class="controls">
      <label>
        <input type="checkbox" id="show-paths" checked>
        Attack Paths
      </label>
      <label>
        <input type="checkbox" id="auto-rotate" checked>
        Auto Rotate
      </label>
      <div class="control-label">Rotation Speed</div>
      <input type="range" id="speed" min="0" max="5" step="0.5" value="1">
    </div>
    <hr>
    <div class="info">
      <div><span id="node-count">0</span> nodes mapped</div>
      <div><span class="highlight" id="path-count">0</span> attack vectors</div>
    </div>
  </div>
  
  <div class="footer">
    <div class="footer-left">UMAP-3D PROJECTION | HETEROGENEOUS GAT</div>
    <div class="footer-right">◉ MANIFOLD STABLE | H₀=6 H₁=3 H₂=1</div>
  </div>
  
  <div class="equation">π: M ⊂ ℝⁿ → T ⊂ ℝ³</div>

  <script>
    // Configuration
    var config = {
      autoRotate: true,
      rotationSpeed: 1,
      showPaths: true
    };
    
    // Cluster definitions
    var clusterDefs = [
      { name: 'Network Infrastructure', color: 0xff6b6b, center: [-2, 0, -1] },
      { name: 'Identity & Access', color: 0x4ecdc4, center: [2, 1, 0] },
      { name: 'Application Layer', color: 0xffe66d, center: [0, -1.5, 2] },
      { name: 'Data Stores', color: 0x95e1d3, center: [-1, 2, 1] },
      { name: 'Endpoint Systems', color: 0xdda0dd, center: [1.5, -0.5, -2] },
      { name: 'Cloud Services', color: 0x87ceeb, center: [0, 0.5, 0] }
    ];
    
    // Seeded random for reproducibility
    function seededRandom(seed) {
      var x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }
    
    // Generate nodes
    var nodes = [];
    clusterDefs.forEach(function(cluster, ci) {
      var count = 12 + Math.floor(seededRandom(ci * 100) * 15);
      for (var i = 0; i < count; i++) {
        var seed = ci * 1000 + i;
        var r = 0.6 + seededRandom(seed) * 0.7;
        var theta = seededRandom(seed + 1) * Math.PI * 2;
        var phi = seededRandom(seed + 2) * Math.PI;
        
        nodes.push({
          cluster: ci,
          color: cluster.color,
          x: cluster.center[0] + r * Math.sin(phi) * Math.cos(theta),
          y: cluster.center[1] + r * Math.sin(phi) * Math.sin(theta),
          z: cluster.center[2] + r * Math.cos(phi),
          size: 0.05 + seededRandom(seed + 3) * 0.05,
          severity: seededRandom(seed + 4)
        });
      }
    });
    
    // Generate attack paths
    var pathDefs = [[0, 4], [4, 1], [1, 3], [2, 5], [5, 0], [3, 2], [0, 1], [4, 3]];
    var paths = [];
    pathDefs.forEach(function(pair, idx) {
      var fromCluster = pair[0];
      var toCluster = pair[1];
      var fromNode = nodes.filter(function(n) { return n.cluster === fromCluster; })[0];
      var toNode = nodes.filter(function(n) { return n.cluster === toCluster; })[0];
      if (fromNode && toNode) {
        paths.push({ from: fromNode, to: toNode });
      }
    });
    
    // Update stats
    var critical = nodes.filter(function(n) { return n.severity > 0.8; }).length;
    var high = nodes.filter(function(n) { return n.severity > 0.6 && n.severity <= 0.8; }).length;
    var medium = nodes.filter(function(n) { return n.severity > 0.4 && n.severity <= 0.6; }).length;
    var low = nodes.filter(function(n) { return n.severity <= 0.4; }).length;
    
    document.getElementById('critical-count').textContent = critical;
    document.getElementById('high-count').textContent = high;
    document.getElementById('medium-count').textContent = medium;
    document.getElementById('low-count').textContent = low;
    document.getElementById('node-count').textContent = nodes.length;
    document.getElementById('path-count').textContent = paths.length;
    
    // Build cluster list UI
    var clusterList = document.getElementById('cluster-list');
    
    var allItem = document.createElement('div');
    allItem.className = 'cluster-item active';
    allItem.innerHTML = '<div class="cluster-dot" style="background: linear-gradient(135deg, #ff6b6b, #4ecdc4);"></div><span>All Clusters</span>';
    allItem.onclick = function() { selectCluster(-1); };
    clusterList.appendChild(allItem);
    
    clusterDefs.forEach(function(cluster, i) {
      var item = document.createElement('div');
      item.className = 'cluster-item';
      var colorHex = cluster.color.toString(16).padStart(6, '0');
      item.innerHTML = '<div class="cluster-dot" style="background: #' + colorHex + ';"></div><span>' + cluster.name + '</span>';
      item.onclick = function() { selectCluster(i); };
      clusterList.appendChild(item);
    });
    
    // Three.js setup
    var container = document.getElementById('container');
    var scene = new THREE.Scene();
    
    var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(6, 4, 6);
    camera.lookAt(0, 0, 0);
    
    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x0a0a1a);
    container.appendChild(renderer.domElement);
    
    // Lighting
    scene.add(new THREE.AmbientLight(0x404060, 0.6));
    
    var light1 = new THREE.PointLight(0xff6b6b, 1, 25);
    light1.position.set(5, 5, 5);
    scene.add(light1);
    
    var light2 = new THREE.PointLight(0x4ecdc4, 0.8, 25);
    light2.position.set(-5, 3, -5);
    scene.add(light2);
    
    // Grid
    var grid = new THREE.GridHelper(10, 20, 0x1a1a3e, 0x1a1a3e);
    grid.position.y = -3;
    scene.add(grid);
    
    // Create node meshes
    var sphereGeo = new THREE.SphereGeometry(1, 20, 20);
    var nodeMeshes = [];
    
    nodes.forEach(function(node) {
      var mat = new THREE.MeshPhongMaterial({
        color: node.color,
        emissive: node.color,
        emissiveIntensity: 0.3,
        transparent: true,
        opacity: 0.85
      });
      
      var mesh = new THREE.Mesh(sphereGeo, mat);
      mesh.position.set(node.x, node.y, node.z);
      mesh.scale.setScalar(node.size);
      mesh.userData = { cluster: node.cluster, baseY: node.y, baseSize: node.size };
      scene.add(mesh);
      nodeMeshes.push(mesh);
    });
    
    // Create path lines
    var pathMeshes = [];
    paths.forEach(function(path) {
      var points = [];
      
      for (var t = 0; t <= 1; t += 0.02) {
        var x = path.from.x + (path.to.x - path.from.x) * t;
        var z = path.from.z + (path.to.z - path.from.z) * t;
        var y = path.from.y + (path.to.y - path.from.y) * t + Math.sin(t * Math.PI) * 0.8;
        points.push(new THREE.Vector3(x, y, z));
      }
      
      var geo = new THREE.BufferGeometry().setFromPoints(points);
      var mat = new THREE.LineBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.5 });
      var line = new THREE.Line(geo, mat);
      scene.add(line);
      pathMeshes.push(line);
    });
    
    // Selection state
    var selectedCluster = -1;
    
    function selectCluster(idx) {
      selectedCluster = idx;
      
      // Update UI
      var items = document.querySelectorAll('.cluster-item');
      items.forEach(function(el, i) {
        if (i === idx + 1) {
          el.classList.add('active');
        } else {
          el.classList.remove('active');
        }
      });
      
      // Update visibility
      nodeMeshes.forEach(function(mesh) {
        var visible = idx === -1 || mesh.userData.cluster === idx;
        mesh.material.opacity = visible ? 0.85 : 0.15;
      });
    }
    
    // Controls
    document.getElementById('show-paths').addEventListener('change', function(e) {
      config.showPaths = e.target.checked;
      pathMeshes.forEach(function(p) { p.visible = config.showPaths; });
    });
    
    document.getElementById('auto-rotate').addEventListener('change', function(e) {
      config.autoRotate = e.target.checked;
    });
    
    document.getElementById('speed').addEventListener('input', function(e) {
      config.rotationSpeed = parseFloat(e.target.value);
    });
    
    // Mouse interaction
    var mouseX = 0, mouseY = 0;
    var targetRotationX = 0, targetRotationY = 0;
    
    document.addEventListener('mousemove', function(e) {
      mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
      mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
    });
    
    // Resize
    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Animation
    var time = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      time += 0.016;
      
      // Rotate scene
      if (config.autoRotate) {
        targetRotationY += 0.003 * config.rotationSpeed;
      }
      targetRotationY += mouseX * 0.002;
      targetRotationX = mouseY * 0.3;
      
      scene.rotation.y += (targetRotationY - scene.rotation.y) * 0.05;
      scene.rotation.x += (targetRotationX - scene.rotation.x) * 0.05;
      
      // Animate nodes
      nodeMeshes.forEach(function(mesh, i) {
        var pulse = 1 + Math.sin(time * 2 + i * 0.3) * 0.08;
        mesh.scale.setScalar(mesh.userData.baseSize * pulse);
        mesh.position.y = mesh.userData.baseY + Math.sin(time + i * 0.5) * 0.03;
      });
      
      renderer.render(scene, camera);
    }
    
    animate();
  </script>
</body>
</html>
